<!DOCTYPE html>
<html>
<head>
<link href="../../bootstrap.min.css" rel="stylesheet" type="text/css">
<title>Chapter 4</title>
</head>
<body>
<div class="container">
<p class="text-center"><img src="chapterFour1.png" width="90%"/></p>
<h3>The Master Theorem</h3>
<p>Let <i>a</i> &#8805; 1 and <i>b</i> &#8805; 1 be constants and let <i>T</i>(<i>n</i>) be defined by the recurrence</p>
<p class="text-center"><i>T</i>(<i>n</i>) = <i>a</i> <i>T</i>(<i>n</i>/<i>b</i>) + <i>f</i>(<i>n</i>)</p>
<p>Then</p>
<ol>
<li>If <i>f</i>(<i>n</i>) = <i>O</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i> - <i>&#949;</i></sup>) for some constant <i>&#949;</i> &gt; 0, then <i>T</i>(<i>n</i>) = <i>&#920;</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>).</li>
<li>If <i>f</i>(<i>n</i>) = <i>&#920;</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>), then <i>T</i>(<i>n</i>) = <i>&#920;</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup> <i>lg</i> <i>n</i>)</li>
<li>If <i>f</i>(<i>n</i>) = <i>&#937;</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i> + <i>&#949;</i></sup>) for some constant <i>&#949;</i> &gt; 0 and <i>a</i> <i>f</i>(<i>n</i>/<i>b</i>) &lt; <i>c</i> <i>f</i>(<i>n</i>) for some <i>c</i> &lt; 1 and all <i>n</i> sufficiently large, then <i>T</i>(<i>n</i>) = <i>&#920;</i>(<i>f</i>(<i>n</i>))</li>
</ol>
<h3>Ideas behind the master theorem</h3>
<p>If we examine the recursive call tree that corresponds to the recurrence</p>
<p class="text-center"><i>T</i>(<i>n</i>) = <i>a</i> <i>T</i>(<i>n</i>/<i>b</i>) + <i>f</i>(<i>n</i>)</p>
<p>we can make the following observations.</p>
<ol>
<li>The height of the call tree is <i>log</i><sub><i>b</i></sub> <i>n</i>.</li>
<li>The number of nodes at level <i>j</i> is <i>a</i><sup><i>j</i></sup>.</li>
<li>The number of leaves is <i>a</i><sup><i>log</i><sub><i>b</i></sub> <i>n</i></sup> = (<i>b</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>)<sup><i>log</i><sub><i>b</i></sub> <i>n</i></sup> = (<i>b</i><sup><i>log</i><sub><i>b</i></sub> <i>n</i></sup>)<sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup> = <i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>.</li>
<li>The additional cost associated with the root node is <i>f</i>(<i>n</i>).</li>
<li>The additional cost associated with each leaf node is <i>O</i>(1).</li>
<li>The cost for all of the leaf nodes is <i>O</i>(1) <i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup> = <i>O</i>(<i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>).</li>
<li>The total cost of the tree will be dominated either by the root cost, <i>f</i>(<i>n</i>), or by the cost of the leaves, <i>n</i><sup><i>log</i><sub><i>b</i></sub> <i>a</i></sup>, whichever is larger. The only tricky case (case 2), happens when these two factors are comparable in size. In that case, the total cost for the tree is given by</li>
<p class="text-center"><img src="chapterFour2.png"/></p>
<p class="text-center"><img src="chapterFour3.png"/></p>
</ol>
<h3>Maximum Subarray Sum - Naive Solution</h3>
<pre>
FIND-MAX-SUBARRAY(A,n)
  max_sum = -&#8734;
  for i = 1 to n
    for j = i to n
      sum = 0;
      for k = i to j
        sum = sum + A[i];
      if sum &gt; max_sum
        max_sum = sum;
        low = i;
        high = j;
  return (low,high,max_sum)
</pre>
<h3>Maximum Subarray Sum - Slightly Less Naive Solution</h3>
<pre>
FIND-MAX-SUBARRAY(A,n)
  max_sum = -&#8734;
  for i = 1 to n
    sum = 0;
    for j = i to n
      sum = sum + A[j];
      if sum &gt; max_sum
        max_sum = sum;
        low = i;
        high = j;
  return (low,high,max_sum)
</pre>
<h3>Maximum Subarray Sum - Recursive Solution</h3>
<pre>
FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)
  left_sum = -&#8734;
  sum = 0
  for i = mid downto low
    sum = sum + A[i]
    if sum &gt; left_sum
      left_sum = sum
      max_left = i
  right_sum = -&#8734;
  sum = 0
  for j = mid + 1 to high
    sum = sum + A[j]
    if sum &gt; right_sum
      right_sum = sum
      max_right = j
  return (max_left,max_right,left_sum+right_sum)

FIND-MAXIMUM-SUBARRAY(A,low,high)
  if high == low
    return (low,high,A[low])
  else mid = (low+high)/2
    (left_low,left_high,left_sum) =
        FIND-MAXIMUM-SUBARRAY(A,low,mid)
    (right_low,right_high,right_sum) =
        FIND-MAXIMUM-SUBARRAY(A,mid,high)
    (cross_low,cross_high,cross_sum) =
        FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)
    if left_sum &gt;= right_sum and left_sum &gt;= cross_sum
      return (left_low,left_high,left_sum)
    else if right_sum &gt;= left_sum and right_sum &gt;= cross_sum
      return (right_low,right_high,right_sum)
    else
      return (cross_low,cross_high,cross_sum)
</pre>
</div>
</body>
</html>
