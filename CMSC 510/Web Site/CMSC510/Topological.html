<!DOCTYPE html>
<html>
<head>
<link href="../bootstrap.min.css" rel="stylesheet" type="text/css">
<title>Topological Sorting</title>
</head>
<body>
<div class="container">
<h3>The problem</h3>
<p>Write a C++ program that uses the approach outlined in problem 22.4-5 to do topological sorting. Demonstrate that your program works correctly by giving it the DAG in Figure 22.7 as its input.</p>
<h3>How to do this</h3>
<p>To help you get started, here is my code for <a href="BFS.zip">the pointer version of BFS</a>. You can use the code I provided for reading a graph from a file to make it easier to construct your graph. You can remove the code to do BFS and the code to print paths - you won't need either of these for the program you are going to write.</p>
<p>The main challenge you are going to face is making an algorithm that does the topological sorting in time <i>O</i>(<i>V</i>+<i>E</i>). To illustrate how tricky this can be, here is a naive implementation of the algorithm.</p>
<ol>
<li>Compute the in-degree of each vertex in the graph. Doing this will require you to examine each edge in the graph, and will take time at least <i>O</i>(<i>E</i>).</li>
<li>Run the algorithm described in 22.4-5. On each round of the algorithm you will have to find a vertex with in-degree 0 and then remove it. Removing the vertex will require you to process each of its out-going edges, which will add a further <i>O</i>(<i>E</i>) over the entire algorithm.</li>
<li>The naive way to find a vertex of in-degree 0 on each round is to simply do a linear search through the list of remaining vertices. If you do this, just searching for the vertices to remove can add total time <i>O</i>(<i>V</i><sup>2</sup>), which exceeds your runtime budget for the algorithm.</li>
</ol>
<p>To beat the run time of <i>O</i>(<i>V</i><sup>2</sup> + <i>E</i>) you will need to replace the idea in step 3 above with something smarter.</p>
</div>
</body>
</html>
