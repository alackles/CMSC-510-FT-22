<!DOCTYPE html>
<html>
<head>
<link href="../bootstrap.min.css" rel="stylesheet" type="text/css">
<title>Loop Invariants</title>
</head>
<body>
<div class="container">
<h1 align="center">Designing Loops with Predicates</h1>
<h2>Proving Programs Correct</h2>
<p>CMSC 510 is a course that will survey a large number of algorithms. For each of these algorithms we will want to describe how the algorithm works, maybe look at an implementation in code, try to assess the run time efficiency of the algorithm, and also present a formal proof of correctness for the algorithm. When I say proof, I mean something very much like a formal mathematical proof of the sort you would see in a math course. The purpose of the proof is to establish by means of formal logic that the algorithm does what it claims to do.</p>
<p>In this handout, we are going to study one aspect of proof of correctness for algorithms, a method for constructing loops that makes use of some of these ideas. The method demonstrated here and the examples used come mostly from the book <i>The Science of Programming</i> by David Gries.</p>
<h3>Predicates and States</h3>
<p>Most program proof schemes are based on applications of the Predicate Calculus, which is a set of rules and techniques for manipulating logical expressions known as <i>predicates</i>. For our present purposes, a predicate is a statement about the current state of a collection of variables found in a program. The statement can be formed from one or more simple assertions about variables, such as <i>i</i> &gt; 10 or <i>a</i>[<i>k</i>] &#8800; <i>x</i>, connected by logical operators, such as <b>and</b>, <b>or</b> , and <b>not</b>. The concept of predicate works hand in hand with the concept of a program's state. The state is essentially a collection of values for the variables in the program. The set of states associated with a given predicate is that collection of values of the variables found in the predicate that will make the predicate be true. The association works both ways: a predicate can be used as a guard at some point in a program to ensure that the variables are in some desired state, or knowledge of the desired state of the program at some point in its execution can be used to construct a goal predicate to describe that state.</p>
<p>Another term sometimes used for predicates in a program is <i>assertions</i>. One can think of assertions as tests or claims about the current state of the program that can be applied at strategic locations in the program. Most often these are the error checks that programmers write into their programs in an effort to catch bugs. This traditional use of predicates is not quite what we have in mind here, because assertions are most often written in as an afterthought and serve only to terminate the program with an error message when they fail. What we have in mind is a use of predicates throughout the design process from the very start. These methods will provide us with careful, structured techniques for designing loops that will simultaneously make them easier to construct and increase our confidence in their correctness.</p>
<h3>A Bit of Notation</h3>
<p>All of the examples below use arrays, and very often we will need to refer to parts of an array, so we will adopt the notation <code>b[i..j]</code> to mean 'that part of the array <code>b</code> between index <code>i</code> and index <code>j</code>'.</p>
<h3>A Common Structure</h3>
<p>The method we will outline here works from the following structure for a loop:</p>
<pre>
&lt; Initialization &gt;
while(! &lt;Termination Condition&gt;)
  &lt;Loop Body&gt;
&lt;Goal State&gt;
</pre>
<p>The general idea is that we do some sort of initialization to prepare for entry into the loop and execute the loop body until the termination condition is true. When execution of the loop is complete, we would then like to have some sort of guarantee that we are in the goal state. Running through this structure is a key predicate called the loop invariant. This invariant ties the whole structure together: the loop invariant must be true after initialization and it must be true after every pass through the loop body. Furthermore, the truth of the loop invariant combined with the truth of the termination condition must be strong enough to satisfy the goal predicate.</p>
<p>The design method for building a loop based on a goal predicate and an invariant starts with the goal predicate. The initial state will not satisfy the goal predicate ( if it did, we wouldn't need to write a loop in the first place! ), so we weaken the goal predicate enough to make the state it describes broad enough to also include the initial state. This weakened goal predicate becomes the loop invariant. Next, we design a termination condition so that <code>&lt;Termination&gt;</code> and <code>&lt;Invariant&gt;</code> implies the <code>&lt;Goal&gt;</code>. The final task is to design a loop body that brings us closer to termination each time we apply it and does not violate the loop invariant.</p>
<h2>A Simple Example</h2>
<p>The first example we are going to look at is quite simple. In fact, it is so simple that you could probably write down the solution yourself without using any of these methods. Nonetheless, it makes a very good first example of how to apply the method.</p>
<p>Suppose that <code>B</code> is an array of <code>n</code> integers, and we know that the value <code>x</code> appears at least once in the array. Write a loop that finds the index of the location where <code>x</code> first appears in the array.</p>
<p>The goal predicate is { (1 &#8804; <i>i</i> &#8804; <i>n</i>) <i>and</i> (<i>b</i>[<i>i</i>] = <i>x</i>) <i>and</i> (<i>b</i>[<i>k</i>] &#8800; <i>x</i> <i>for</i> <i>all</i> 1 &#8804; <i>k</i> &lt; <i>i</i>) }. The best way to weaken this predicate is to drop one of the three requirements: the most obvious one is the requirement that (<i>b</i>[<i>i</i>] = <i>x</i>), for that seems to be the one that would signal success. The weakened predicate, { (1 &#8804; <i>i</i> &#8804; <i>n</i>) <i>and</i> (<i>b</i>[<i>k</i>] &#8800; <i>x</i> <i>for</i> <i>all</i> 1 &#8804; <i>k</i> &lt; <i>i</i>) } becomes the invariant. The condition we dropped becomes the termination condition because <code>&lt;Termination&gt;</code> and <code>&lt;Invariant&gt;</code> should be the <code>&lt;Goal&gt;</code>. Next, we write down an obvious initialization condition, { <i>i</i> = 1 }, and check that it satisfies the invariant. ( It satisfies it trivially because there are no <code>k</code>'s such that 1 &#8804; <i>k</i> &lt; <i>i</i> when <i>i</i> = 1. ) Finally, we write a trivial loop body. About the only thing the loop body has to do is to get us closer to termination each time it is applied. The statement <code>i++</code>; will do just fine. Here then is the final form of the loop with the predicates attached:</p>
<pre>
i = 1;
// i = 1
while(b[i] != x )
  i++;
// (1 &lt;= i &lt;= n) and (b[i] = x) and (b[k] != x for all 1 &lt;= k &lt; i)
</pre>
<p>Recall that we said that the invariant has to be true after each pass through the loop body. Let's check that this is actually the case. First of all, note that for the loop body to get a chance to execute, we have to make it past the termination condition. Also, the invariant will still be true from the initialization or the last pass through the loop. That means that before the execution of the statement, we have { (1 &#8804; <i>i</i> &#8804; <i>n</i>) <i>and</i> (<i>b</i>[<i>k</i>] &#8800; <i>x</i> <i>for</i> <i>all</i> 1 &#8804; <i>k</i> &lt; <i>i</i>) } and <i>b</i>[<i>i</i>] &#8800; <i>x</i>. This implies that { (1 &#8804; <i>i</i>+1 &#8804; <i>n</i>) <i>and</i> (<i>b</i>[<i>k</i>] &#8800; <i>x</i> <i>for</i> <i>all</i> 1 &#8804; <i>k</i> &lt; <i>i</i>+1) }. ( Why is <i>i</i>+1 &#8804; <i>n</i>? ) Notice that we can safely replace <code>i + 1</code> with <code>i</code> in this predicate and have it still be true. That is exactly what the <code>i++</code> statement does; in fact, replacing <code>i + 1</code> with <code>i</code> gives us the invariant back again and guarantees its truth. At the same time, doing this brings us closer to termination.</p>
<h2>The Plateau Problem</h2>
<p>Suppose <code>b</code> is an array of <code>n</code> integers sorted in ascending order. We want to write a loop to find the length of the longest plateau, or string of identical numbers, in the array. Our goal is to find a number <code>p</code> with the property that ( <code>b[1..n]</code> contains a plateau of length <code>p</code>) and ( <code>b[1..n]</code> does not contain a plateau of length <code>p + 1</code> ). A more precise way to write the goal predicate is to say ( <i>There</i> <i>is</i> <i>a</i> <i>k</i> , 1 &#8804; <i>k</i> &#8804; <i>n</i> + 1 - <i>p</i>, <i>such</i> <i>that</i> <i>b</i>[<i>k</i>] = <i>b</i>[<i>k</i>+<i>p</i>-1] ) and ( <i>For</i> <i>all</i> <i>k</i>, 1 &#8804; <i>k</i> &#8804; <i>n</i> - <i>p</i>, <i>b</i>[<i>k</i>] &#8800; <i>b</i>[<i>k</i>+<i>p</i>] ) This predicate comes from the observation that since the elements in the array are ordered, to check for a plateau of length <code>p</code> one just has to find two elements <code>p</code> steps apart that are the same.</p>
<p>Note that the goal will be satisfied after we have had a chance to search all of <code>b</code>. An obvious way to weaken the goal into an invariant is to have the invariant talk about our having just searched part of the array. The invariant becomes {( <i>b</i>[1..<i>i</i>] <i>contains</i> <i>a</i> <i>plateau</i> <i>of</i> <i>length</i> <i>p</i> ) <i>and</i> ( <i>b</i>[1..<i>i</i>] <i>does</i> <i>not</i> <i>contain</i> <i>a</i> <i>plateau</i> <i>of</i> <i>length</i> <i>p</i> + 1 ) <i>and</i> ( 1 &#8804; <i>i</i> &#8804; <i>n</i> )}  The termination condition is obvious: the loop stops when <i>i</i> = <i>n</i>. An obvious initialization condition satisfying the invariant is { (<i>i</i> = 1) <i>and</i> ( <i>p</i> = 1) }.</p>
<p>The only thing left to do now is to write a loop body. In order to figure out what the loop body should be, let's start with a stupid guess, <code>i++</code>, and see that the guess would violate the invariant. Before application of the loop statement, the invariant has to be true and the termination condition false. That is, {( <i>b</i>[1..<i>i</i>] <i>contains</i> <i>a</i> <i>plateau</i> <i>of</i> <i>length</i> <i>p</i> ) <i>and</i> ( <i>b</i>[1..<i>i</i>] <i>does</i> <i>not</i> <i>contain</i> <i>a</i> <i>plateau</i> <i>of</i> <i>length</i> <i>p</i> + 1 ) <i>and</i> ( 1 &#8804; <i>i</i> &#8804; <i>n</i> )} and <i>i</i> &lt; <i>n</i>. The problem with just blindly increasing <code>i</code> is that we could already be sitting at the end of a plateau of length <code>p</code>, and bumping up <code>i</code> by one could cause us to have a plateau of length <code>p+1</code> and hence violate the invariant. The way out of this problem is to check whether or not bumping up <code>i</code> would cause us to have a plateau of length <code>p+1</code> ending at <code>i+1</code>: if it does, we bump up <code>p</code> by one at the same time that we bump up <code>i</code> by one. The invariant would still be true then because we will be certain of the existence of a plateau of length <code>p</code> for the new larger <code>p</code>. Here is the final version of the code with the appropriate documentation:</p>
<pre>
i = 1;
p = 1;
// Loop invariant :
// ( b[1..i] contains a plateau of length p ) and
// ( b[1..i] does not contain a plateau of length p + 1 )
// and ( 1 &lt;= i &lt;= n )
while(i &lt; n)
  {
  if (b[i+1] == b[i+1-p])
    p++;
  i++;
  }
// Goal :
// ( b[1..n] contains a plateau of length p) and
// ( b[1..n] does not contain a plateau of length p + 1 )

</pre>
<h2>A Sorting Algorithm</h2>
<p>Now that we have seen a couple of examples, it is time to turn our attention to a problem that more closely approaches the kind of problems real programmers have to contend with. In this next example we are going to look at a sorting algorithm called bubble sort. This is an example of a relatively inefficient sorting algorithm, but it has enough complexity to make it worth our time to study it.</p>
<p>In the discussion below, the notation <i>A</i>[1..<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>] stands for &quot;every element in the range <i>A</i>[1..<i>i</i>] is less than or equal to every element in the range <i>A</i>[<i>i</i>+1..<i>n</i>].&quot; Further, if one or both of the two ranges is empty, the statement is understood to be trivially true.</p>
<p><b>The Code</b></p>
<p>Suppose <code>A[1..n]</code> is an initially unsorted array of integers. Here is some code to sort the array using the bubble sort algorithm.</p>
<pre>
i = 1;
while(i &lt;= n)
  {
  j = n;
  while(j &gt; i)
    {
    if(A[j] &lt; A[j-1])
      {
      temp = A[j-1];
      A[j-1] = A[j]
      A[j] = temp;
      }
    j--;
    }
  i++;
  }
</pre>
<h3>Analysis of the inner loop</h3>
<p>Since this code is structured as a pair of nested loops, we will apply the proof technique to both loops in turn. Since the outer loop will rely on the inner loop, we start our analysis with the inner loop.</p>
<p>&lt;<i>goal</i>&gt; = &quot;<i>A</i>[<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>]&quot;</p>
<p>&lt;<i>invariant</i>&gt; = &quot;<i>A</i>[<i>j</i>] &#8804; <i>A</i>[<i>j</i>+1..<i>n</i>]&quot;</p>
<p>&lt;<i>initialization</i>&gt; = &quot;<i>j</i> = <i>n</i>&quot;</p>
<p>&lt;<i>termination</i>&gt; = &quot;<i>j</i> = <i>i</i>&quot;</p>
<p>The invariant is trivially true at initialization time because the range <i>A</i>[<i>j</i>+1..<i>n</i>] is empty. It is also easy to see that &lt;<i>invariant</i>&gt; + &lt;<i>termination</i>&gt; = &lt;<i>goal</i>&gt;. The only thing to prove is that the loop body maintains the invariant.</p>
<p>At the beginning of the loop body we have that <i>A</i>[<i>j</i>] is the smallest element in <i>A</i>[<i>j</i>..<i>n</i>]. If <i>A</i>[<i>j</i>] is also smaller than <i>A</i>[<i>j</i>-1], we make the two trade places so that now <i>A</i>[<i>j</i>-1] &#8804; <i>A</i>[<i>j</i>..<i>n</i>]. Otherwise, we leave <i>A</i>[<i>j</i>-1] in place so that once again <i>A</i>[<i>j</i>-1] &#8804; <i>A</i>[<i>j</i>..<i>n</i>]. After doing the decrement of <i>j</i> at the end of the loop body the inequality looks like the invariant again because the decrement effectively replaces <i>j</i>-1 with <i>j</i>.</p>
<h3>Analysis of the outer loop</h3>
<p>&lt;<i>goal</i>&gt; = &quot;<i>A</i>[1..<i>n</i>] is sorted&quot;</p>
<p>&lt;<i>invariant</i>&gt; = &quot;(<i>A</i>[1..<i>i</i>-1] is sorted) and (<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>])&quot;</p>
<p>&lt;<i>initialization</i>&gt; = &quot;<i>i</i> = 1&quot;</p>
<p>&lt;<i>termination</i>&gt; = &quot;<i>i</i> = <i>n</i> + 1&quot;</p>
<p>The invariant is trivially true at initialization time because the range <i>A</i>[1..<i>i</i>-1] is empty. &lt;<i>invariant</i>&gt; + &lt;<i>termination</i>&gt; = &lt;<i>goal</i>&gt; because at termination time <i>A</i>[1..<i>i</i>-1] = <i>A</i>[1..<i>n</i>] and the range <i>A</i>[<i>i</i>..<i>n</i>] is empty at termination. That means that at termination the invariant reduces to &quot;(<i>A</i>[1..<i>n</i>] is sorted) and (true)&quot;, which is the same as &lt;<i>goal</i>&gt;.</p>
<p>At the beginning of the outer loop body we have &quot;(<i>A</i>[1..<i>i</i>-1] is sorted) and (<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>])&quot;. After execution of the inner loop we also have &quot;<i>A</i>[<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>]&quot;. The condition (<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>]) implies that <i>A</i>[<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>], because <i>A</i>[<i>i</i>] is just one element of the larger range <i>A</i>[<i>i</i>..<i>n</i>] and  <i>A</i>[<i>i</i>-1] is a representative of the range <i>A</i>[1..<i>i</i>-1]. Combining (<i>A</i>[1..<i>i</i>-1] is sorted) with (<i>A</i>[<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>]) gives (<i>A</i>[1..<i>i</i>] is sorted). This maintains the first half of the invariant. Coupling the inner loop goal &quot;<i>A</i>[<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>]&quot; with (<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>]) leads to (<i>A</i>[1..<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>]), maintaining the second half of the invariant.</p>
<p>After execution of the inner loop we have  &quot;(<i>A</i>[1..<i>i</i>] is sorted) and (<i>A</i>[1..<i>i</i>] &#8804; <i>A</i>[<i>i</i>+1..<i>n</i>])&quot;. Incrementing <i>i</i> at the end of the outer loop body restores the invariant back to the original  &quot;(<i>A</i>[1..<i>i</i>-1] is sorted) and (<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>])&quot;.</p>
<h3>Commentary</h3>
<p>Here are some things to think about when designing invariants.</p>
<ul>
<li>Make your invariant as strong as possible. Generally speaking, the strongest possible invariant that is still true at initialization is best. That is why the outer loop invariant used above is better than the weaker &quot;<i>A</i>[1..<i>i</i>-1] is sorted&quot;.</li>
<li>In a nested loop situation, the best outer loop invariant is one that has something to do conceptually with what the inner loop is trying to accomplish. That is why the part of the outer invariant that says &quot;<i>A</i>[1..<i>i</i>-1] &#8804; <i>A</i>[<i>i</i>..<i>n</i>]&quot; is a good choice.</li>
<li>To prove that an invariant is maintained by a loop body, the only things you have to go on are the truth of the invariant at the start of the loop body and the code in the loop body itself. This is another reason to make the invariant as strong as possible, because a stronger, more detailed invariant carries more useful information.</li>
</ul>
<h2 id="exercise">Homework Assignment</h2>
<p>Write out the pseudocode for a function <code>Intersection(A,B)</code> which computes the intersection of two lists of integers. You may assume that the numbers in arrays A and B are sorted in ascending order, and that neither of the two lists contains duplicate elements.</p>
<p>Use the following structure for your code:</p>
<ol>
<li>Count the number of elements in A that also appear in B.</li>
<li>Construct a new array, C, of that size.</li>
<li>Copy the elements in A that also appear in B to C.</li>
<li>Return the array C.</li>
</ol>
<p>Construct a proof of correctness for the loop you wrote to handle part 3 above. For the purpose of the proof, you may assume that the count you computed in part 1 is correct.</p>
<h2>The GCD problem</h2>
<p>The greatest common divisor function takes two positive integers, <code>X</code> and <code>Y</code>, as input and returns the largest positive integer, <code>y</code>, that evenly divides both <code>X</code> and <code>Y</code>. Let us see how to write a loop to compute a greatest common divisor.</p>
<p>The result that we want is a proof of </p>
<pre>
{ <i>y</i> = <i>GCD</i>(<i>X</i>,<i>Y</i>) }
</pre>
<p>The key to this problem is a trio of properties of the GCD function that are easily verified:</p>
<pre>
<i>GCD</i>(<i>y</i>,0) = <i>y</i>
<i>if</i> <i>x</i> &lt;= <i>y</i>, <i>GCD</i>(<i>x</i>,<i>y</i>) = <i>GCD</i>(<i>x</i>,<i>y</i>-<i>x</i>)
<i>GCD</i>(<i>x</i>,<i>y</i>) = <i>GCD</i>(<i>y</i>,<i>x</i>)
</pre>
<p>The first property allows us to recast the goal as</p>
<pre>
{ <i>y</i> = <i>GCD</i>(0,<i>y</i>) = <i>GCD</i>(<i>X</i>,<i>Y</i>) }
</pre>
<p>Given this set-up, a strategy suggests itself: start by setting <code>x</code> to <code>X</code> and <code>y</code> to <code>Y</code>. Try to drive the value of <code>x</code> down until it hits zero, all the while making sure that <code>GCD(x,y)</code> stays equal to <code>GCD(X,Y)</code> as we change <code>x</code> and <code>y</code>.</p>
<p>We have everything we need now: we have a start condition:</p>
<pre>
{ <i>x</i> = <i>X</i>, <i>y</i> = <i>Y</i> }
</pre>
<p>an invariant,</p>
<pre>
{ <i>GCD</i>(<i>x</i>,<i>y</i>) = <i>GCD</i>(<i>X</i>,<i>Y</i>) }
</pre>
<p>and a goal</p>
<pre>
{ <i>x</i> = 0 <i>and</i> <i>GCD</i>(<i>x</i>,<i>y</i>) = <i>GCD</i>(<i>X</i>,<i>Y</i>) }
</pre>
<p>Clearly the invariant is true at start and at the goal, so all that we need now is some way to make a loop that maintains the invariant and makes progress toward the goal. The key to making progress toward the goal is the second of the three properties mentioned above. Here is a loop that uses this property to make progress to termination:</p>
<pre>
x = X;
y = Y;
// Loop invariant
// x &gt;= 0 and y &gt;= 0 and GCD(x,y) = GCD(X,Y)
while(x &gt; 0)
  if(x &lt;= y)
    y = y-x
    // This branch maintains the loop invariant
    // by property (2) of the GCD
  else
    {
    temp = x;
    x = y;
    y = temp;
    // This branch maintains the loop invariant
    // by property (3) of the GCD
    }
// After termination, x = 0 and GCD(x,y) = GCD(X,Y)
// By property (1) of GCD we have y = GCD(X,Y)
</pre>
<p>The loop body makes progress toward this goal by reducing <code>y</code> until it is smaller than <code>x</code>. When <code>y</code> is smaller than <code>x</code>, the two are switched and the process continues. Notice that this really does make progress toward termination because except for the occasional swap, <code>y</code> continues to decrease in size.</p>
<p>Finally, let us make two small adjustments to increase the efficiency of the loop. Instead of subtracting just one <code>x</code> from <code>y</code> each time we do a subtraction, lets subtract as many copies of <code>x</code> as we can get away with. What do you get when you subtract <code>x</code> from <code>y</code> as many times as possible? You get <code>y mod x</code>! This simple observation speeds the code up. Also, when we do <code>y = y % x</code>, the result will automatically make <code>y</code> smaller than <code>x</code>. The next time around the loop we will then definitely have to do a swap. We can make a short-cut by doing the swap at the same time as the mod:</p>
<pre>
x = X;
y = Y;
if(y &lt; x)
  {
  temp = x;
  x = y;
  y = temp;
  }
// Loop invariant
// y &gt;= x and x &gt;= 0 and GCD(x,y) = GCD(X,Y)
while(x &gt; 0)
  {
  temp = y % x;
  y = x;
  x = temp;
  // Maintains the invariant by properties (2) and (3) of GCD
  }
// After termination, x = 0 and GCD(x,y) = GCD(X,Y)
// By property (1) of GCD we have y = GCD(X,Y)
</pre>
<h2>A Slick Exponentiation Algorithm</h2>
<p>Computing <code>X</code><sup>Y</sup> for positive integers <code>X</code> and <code>Y</code> is a trivial exercise in loop writing:</p>
<pre>
z = x;
t = y;
while(t &gt; 0)
  {
  z = z * x;
  t = t -1;
  }
</pre>
<p>Is this solution correct? At termination, we have <code>t = 0</code> and <code>z</code> should be <code>x</code><sup>y</sup>. At start, we have <code>t = y</code> and <code>z = x</code>. What sort of invariant would cover both of these conditions? The correct invariant for this problem is <code>x</code><sup>y</sup><code> = z * x</code><sup>t</sup>. This is appropriate because it captures the central idea: as <code>t</code> decreases, <code>z</code> should increase to keep the equality true. We can also see that the initialization is wrong. { <i>z</i> = <i>x</i> <i>and</i> <i>t</i> = <i>y</i> } does not satisfy the invariant. To fix it, we should say { <i>z</i> = <i>x</i> <i>and</i> <i>t</i> = <i>y</i> - 1 }. </p>
<p>We measure progress toward termination in this example by reducing <code>t</code>. The rate at which we reduce <code>t</code> also determines how long the loop takes to run. Can we think of a faster way to decrease <code>t</code> and still have the loop invariant be true after each iteration?</p>
<p>A faster way to reduce <code>t</code> is to do <code>t = t/2</code> each time through ( provided <code>t</code> is even ). We can do this and still preserve the invariant by letting the <code>x</code> above be a variable instead of being fixed at <code>x</code>. The new invariant is  <code>x</code><sup>y</sup><code> = z * s</code><sup>t</sup>. Notice that we can maintain the invariant by saying <code>s = s*s</code> at the same time we do <code>t = t/2</code>. Here is the loop in the faster version:</p>
<pre>
z = x;
s = x;
t = y - 1;
while(t &gt; 0)
  if(t % 2 == 0)
    {
    t = t / 2;
    s = s * s;
    }
  else
    {
    z = z * s;
    t = t -1;
    }
</pre>
</div>
</body>
</html>
