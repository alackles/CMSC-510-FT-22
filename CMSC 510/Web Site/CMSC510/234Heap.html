<!DOCTYPE html>
<html>
<head>
<link href="../bootstrap.min.css" rel="stylesheet" type="text/css">
<title>2-3-4 Heaps</title>
</head>
<body>
<div class="container">
<h3>The problem</h3>
<p>Write a C++ program that implements the 2-3-4 heap data structure described in exercise 19-4.</p>
<h3>Hints and suggestions</h3>
<p>The 2-3-4 heap has some features in common with the 2-3-4 tree, which is a kind of B-tree. You can find a discussion of B-trees, including pseudocode for most operations, in chapter 18.</p>
<p>The 2-3-4 heap does have some important differences from B-trees, so you will have to adjust your logic appropriately. (Fortunately almost all of these differences result in the 2-3-4 heap being easier to implement than a 2-3-4 tree.)</p>
<p>Here are some of the most significant differences:</p>
<ol>
<li>2-3-4 heaps store keys only in the leaf nodes, while 2-3-4 trees store keys in each node.</li>
<li>Leaf nodes in a 2-3-4 tree are ordered in increasing order as you read across the leaves from left to right. Leaf nodes in a 2-3-4 heap have no particular order.</li>
<li>Because leaf nodes in a 2-3-4 tree have to be ordered, each item that you insert has to go to a particular location. Since 2-3-4 heaps don't order their leaves you are free to insert new leaves whereever it is most convenient for you. (I suggest inserting new leaves all the way to the right of the sequence of leaves.)</li>
<li>As stated in the problem statement, when you go to delete a leaf you will be given a pointer to that leaf. This means that you won't have to search for the leaf node to delete. The delete algorithm for 2-3-4 trees starts with a search to find the leaf to delete: you won't have to do that search.</li>
<li>For the decrease-key operation you will also be given a pointer to the leaf whose key you need to decrease.</li>
</ol>
<p>Here are some further suggestions on how to write the C++ program. The first thing you will have to deal with is the fact that internal nodes and leaf nodes have different structures. The standard way to handle this kind of thing is to use inheritance: we make a base class for nodes and then two derived classes for internal nodes and leaf nodes:</p>
<pre>
// Forward declarations of child classes
template &lt;typename T&gt; class Leaf;
template &lt;typename T&gt; class Internal;

template &lt;typename T&gt; class Node {
protected:
  Internal&lt;T&gt;* parent;
public:
  virtual Leaf&lt;T&gt;* toLeaf() { return nullptr; }
  virtual Internal&lt;T&gt;* toInternal() { return nullptr; }
};

template &lt;typename T&gt; class Leaf : public Node&lt;T&gt; {
private:
  T key;
public:
  virtual Leaf&lt;T&gt;* toLeaf() { return this; }
};

template &lt;typename T&gt; class Internal : public Node&lt;T&gt; {
private:
  T min;
  Node&lt;T&gt;* children[4];
  int childCount;
public:
  virtual Internal&lt;T&gt;* toInternal() { return this; }
};
</pre>
<p>You will of course need to add constructors and additional member functions to handle all of the operations.</p>
</div>
</body>
</html>
